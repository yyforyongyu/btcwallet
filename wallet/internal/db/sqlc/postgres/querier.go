// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlcpg

import (
	"context"
)

type Querier interface {
	// Inserts the encrypted private key material for an account.
	CreateAccountSecret(ctx context.Context, arg CreateAccountSecretParams) error
	// Creates a new derived account under the given scope, computing the next
	// account number atomically. The caller MUST call LockAccountScope first
	// to acquire the advisory lock and prevent race conditions.
	// See LockAccountScope comments for why this is a separate statement.
	CreateDerivedAccount(ctx context.Context, arg CreateDerivedAccountParams) (CreateDerivedAccountRow, error)
	// Test-only: Creates a derived account with a specific account number.
	// Used for testing account number overflow without creating billions of accounts.
	CreateDerivedAccountWithNumber(ctx context.Context, arg CreateDerivedAccountWithNumberParams) (CreateDerivedAccountWithNumberRow, error)
	// Creates a new imported account under the given scope with NULL account
	// number. Imported accounts don't follow BIP44 derivation, so they don't need
	// a sequential account number.
	CreateImportedAccount(ctx context.Context, arg CreateImportedAccountParams) (CreateImportedAccountRow, error)
	// Creates a new key scope for a wallet and returns its ID.
	CreateKeyScope(ctx context.Context, arg CreateKeyScopeParams) (int64, error)
	CreateWallet(ctx context.Context, arg CreateWalletParams) (int64, error)
	DeleteBlock(ctx context.Context, blockHeight int32) error
	// Deletes a key scope by its ID.
	DeleteKeyScope(ctx context.Context, id int64) (int64, error)
	// Deletes the secrets for a key scope.
	DeleteKeyScopeSecrets(ctx context.Context, scopeID int64) (int64, error)
	// Returns a single account by scope id and account name.
	GetAccountByScopeAndName(ctx context.Context, arg GetAccountByScopeAndNameParams) (GetAccountByScopeAndNameRow, error)
	// Returns a single account by scope id and account number.
	GetAccountByScopeAndNumber(ctx context.Context, arg GetAccountByScopeAndNumberParams) (GetAccountByScopeAndNumberRow, error)
	// Returns a single account by wallet id, scope tuple, and account name.
	GetAccountByWalletScopeAndName(ctx context.Context, arg GetAccountByWalletScopeAndNameParams) (GetAccountByWalletScopeAndNameRow, error)
	// Returns a single account by wallet id, scope tuple, and account number.
	GetAccountByWalletScopeAndNumber(ctx context.Context, arg GetAccountByWalletScopeAndNumberParams) (GetAccountByWalletScopeAndNumberRow, error)
	// Returns full account properties by account id.
	GetAccountPropsById(ctx context.Context, id int64) (GetAccountPropsByIdRow, error)
	// Returns a single address type by its ID.
	GetAddressTypeByID(ctx context.Context, id int16) (AddressType, error)
	GetBlockByHeight(ctx context.Context, blockHeight int32) (Block, error)
	// Retrieves a key scope by its ID.
	GetKeyScopeByID(ctx context.Context, id int64) (KeyScope, error)
	// Retrieves a key scope by wallet ID, purpose, and coin type.
	GetKeyScopeByWalletAndScope(ctx context.Context, arg GetKeyScopeByWalletAndScopeParams) (KeyScope, error)
	// Retrieves the secrets for a key scope.
	GetKeyScopeSecrets(ctx context.Context, scopeID int64) (KeyScopeSecret, error)
	GetWalletByID(ctx context.Context, id int64) (GetWalletByIDRow, error)
	GetWalletByName(ctx context.Context, walletName string) (GetWalletByNameRow, error)
	GetWalletSecrets(ctx context.Context, walletID int64) (WalletSecret, error)
	InsertBlock(ctx context.Context, arg InsertBlockParams) error
	// Inserts secrets for a key scope. encrypted_coin_priv_key may be NULL for
	// watch-only scopes.
	InsertKeyScopeSecrets(ctx context.Context, arg InsertKeyScopeSecretsParams) error
	InsertWalletSecrets(ctx context.Context, arg InsertWalletSecretsParams) error
	InsertWalletSyncState(ctx context.Context, arg InsertWalletSyncStateParams) error
	// Lists all accounts in a scope, ordered by account number. Imported accounts
	// (with NULL account_number) appear last.
	ListAccountsByScope(ctx context.Context, scopeID int64) ([]ListAccountsByScopeRow, error)
	// Lists all accounts for a wallet, ordered by account number. Imported
	// accounts (with NULL account_number) appear last.
	ListAccountsByWallet(ctx context.Context, walletID int64) ([]ListAccountsByWalletRow, error)
	// Lists all accounts for a wallet filtered by account name, ordered by account
	// number. Imported accounts (with NULL account_number) appear last.
	ListAccountsByWalletAndName(ctx context.Context, arg ListAccountsByWalletAndNameParams) ([]ListAccountsByWalletAndNameRow, error)
	// Lists all accounts for a wallet and scope tuple, ordered by account number.
	// Imported accounts (with NULL account_number) appear last.
	ListAccountsByWalletScope(ctx context.Context, arg ListAccountsByWalletScopeParams) ([]ListAccountsByWalletScopeRow, error)
	// Returns all address types ordered by ID.
	ListAddressTypes(ctx context.Context) ([]AddressType, error)
	// Lists all key scopes for a wallet, ordered by ID.
	ListKeyScopesByWallet(ctx context.Context, walletID int64) ([]KeyScope, error)
	ListWallets(ctx context.Context) ([]ListWalletsRow, error)
	// Acquires a transaction-level advisory lock to serialize account creation within a scope.
	// The lock is automatically released upon transaction commit or rollback.
	// This MUST be called immediately before 'CreateDerivedAccount' within the same transaction.
	//
	// We explicitly use a two-statement pattern because single-statement CTE/Join
	// approaches failed to prevent race conditions during concurrent account generation.
	// The following "one-query" strategies were tested and proven unreliable:
	//
	// 1. CTE with CROSS/INNER JOIN: The PostgreSQL optimizer may evaluate the
	//    MAX(account_number) subquery using a snapshot taken before the lock CTE
	//    is fully processed, leading to duplicate account numbers.
	//
	// 2. CTE with OFFSET 0: Designed to force materialization, this still fails to
	//    guarantee that the lock is held before the aggregate subquery begins its
	//    read operation.
	//
	// 3. FOR UPDATE in Subqueries: Since FOR UPDATE targets existing rows, it fails
	//    to "lock the gap" for new inserts or handle empty tables, allowing
	//    concurrent processes to calculate identical MAX() values.
	//
	// Using two separate calls ensures the application pauses until
	// LockAccountScope returns, guaranteeing that the subsequent SELECT MAX()
	// operates inside a strictly serialized execution window for that scope.
	LockAccountScope(ctx context.Context, dollar_1 int64) error
	// Renames an account identified by wallet id, scope tuple, and current account name.
	UpdateAccountNameByWalletScopeAndName(ctx context.Context, arg UpdateAccountNameByWalletScopeAndNameParams) (int64, error)
	// Renames an account identified by wallet id, scope tuple, and account number.
	UpdateAccountNameByWalletScopeAndNumber(ctx context.Context, arg UpdateAccountNameByWalletScopeAndNumberParams) (int64, error)
	UpdateWalletSecrets(ctx context.Context, arg UpdateWalletSecretsParams) (int64, error)
	UpdateWalletSyncState(ctx context.Context, arg UpdateWalletSyncStateParams) (int64, error)
}

var _ Querier = (*Queries)(nil)
