// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: accounts.sql

package sqlcpg

import (
	"context"
	"database/sql"
	"time"
)

const CreateAccountSecret = `-- name: CreateAccountSecret :exec
INSERT INTO account_secrets (
    account_id,
    encrypted_private_key
) VALUES (
    $1, $2
)
`

type CreateAccountSecretParams struct {
	AccountID           int64
	EncryptedPrivateKey []byte
}

// Inserts the encrypted private key material for an account.
func (q *Queries) CreateAccountSecret(ctx context.Context, arg CreateAccountSecretParams) error {
	_, err := q.exec(ctx, q.createAccountSecretStmt, CreateAccountSecret, arg.AccountID, arg.EncryptedPrivateKey)
	return err
}

const CreateDerivedAccount = `-- name: CreateDerivedAccount :one
WITH allocated_number AS (
    UPDATE key_scopes
    SET last_account_number = last_account_number + 1
    WHERE key_scopes.id = $1
    RETURNING key_scopes.id, last_account_number AS account_number
)

INSERT INTO accounts (
    scope_id,
    account_number,
    account_name,
    origin_id,
    encrypted_public_key,
    master_fingerprint,
    is_watch_only
)
SELECT
    allocated_number.id AS scope_id,
    allocated_number.account_number,
    $2 AS account_name,
    $3 AS origin_id,
    $4 AS encrypted_public_key,
    $5 AS master_fingerprint,
    $6 AS is_watch_only
FROM allocated_number
RETURNING accounts.id, accounts.account_number, accounts.created_at
`

type CreateDerivedAccountParams struct {
	ID                 int64
	AccountName        string
	OriginID           int16
	EncryptedPublicKey []byte
	MasterFingerprint  sql.NullInt64
	IsWatchOnly        bool
}

type CreateDerivedAccountRow struct {
	ID            int64
	AccountNumber sql.NullInt64
	CreatedAt     time.Time
}

// Creates a new derived account under the given scope, allocating a fresh
// sequential account number from key_scopes.last_account_number.
// The allocation is atomic: the UPDATE takes the row lock on the scope row,
// returns the allocated number, and updates the counter for the next call.
func (q *Queries) CreateDerivedAccount(ctx context.Context, arg CreateDerivedAccountParams) (CreateDerivedAccountRow, error) {
	row := q.queryRow(ctx, q.createDerivedAccountStmt, CreateDerivedAccount,
		arg.ID,
		arg.AccountName,
		arg.OriginID,
		arg.EncryptedPublicKey,
		arg.MasterFingerprint,
		arg.IsWatchOnly,
	)
	var i CreateDerivedAccountRow
	err := row.Scan(&i.ID, &i.AccountNumber, &i.CreatedAt)
	return i, err
}

const CreateImportedAccount = `-- name: CreateImportedAccount :one
INSERT INTO accounts (
    scope_id,
    account_number,
    account_name,
    origin_id,
    encrypted_public_key,
    master_fingerprint,
    is_watch_only
)
VALUES ($1, NULL, $2, $3, $4, $5, $6)
RETURNING id, created_at
`

type CreateImportedAccountParams struct {
	ScopeID            int64
	AccountName        string
	OriginID           int16
	EncryptedPublicKey []byte
	MasterFingerprint  sql.NullInt64
	IsWatchOnly        bool
}

type CreateImportedAccountRow struct {
	ID        int64
	CreatedAt time.Time
}

// Creates a new imported account under the given scope with NULL account
// number. Imported accounts don't follow BIP44 derivation, so they don't need
// a sequential account number.
func (q *Queries) CreateImportedAccount(ctx context.Context, arg CreateImportedAccountParams) (CreateImportedAccountRow, error) {
	row := q.queryRow(ctx, q.createImportedAccountStmt, CreateImportedAccount,
		arg.ScopeID,
		arg.AccountName,
		arg.OriginID,
		arg.EncryptedPublicKey,
		arg.MasterFingerprint,
		arg.IsWatchOnly,
	)
	var i CreateImportedAccountRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const GetAccountByScopeAndName = `-- name: GetAccountByScopeAndName :one
SELECT
    a.account_number,
    a.account_name,
    a.origin_id,
    a.is_watch_only,
    a.created_at,
    ks.purpose,
    ks.coin_type
FROM accounts AS a
INNER JOIN key_scopes AS ks ON a.scope_id = ks.id
WHERE a.scope_id = $1 AND a.account_name = $2
`

type GetAccountByScopeAndNameParams struct {
	ScopeID     int64
	AccountName string
}

type GetAccountByScopeAndNameRow struct {
	AccountNumber sql.NullInt64
	AccountName   string
	OriginID      int16
	IsWatchOnly   bool
	CreatedAt     time.Time
	Purpose       int64
	CoinType      int64
}

// Returns a single account by scope id and account name.
func (q *Queries) GetAccountByScopeAndName(ctx context.Context, arg GetAccountByScopeAndNameParams) (GetAccountByScopeAndNameRow, error) {
	row := q.queryRow(ctx, q.getAccountByScopeAndNameStmt, GetAccountByScopeAndName, arg.ScopeID, arg.AccountName)
	var i GetAccountByScopeAndNameRow
	err := row.Scan(
		&i.AccountNumber,
		&i.AccountName,
		&i.OriginID,
		&i.IsWatchOnly,
		&i.CreatedAt,
		&i.Purpose,
		&i.CoinType,
	)
	return i, err
}

const GetAccountByScopeAndNumber = `-- name: GetAccountByScopeAndNumber :one
SELECT
    a.account_number,
    a.account_name,
    a.origin_id,
    a.is_watch_only,
    a.created_at,
    ks.purpose,
    ks.coin_type
FROM accounts AS a
INNER JOIN key_scopes AS ks ON a.scope_id = ks.id
WHERE a.scope_id = $1 AND a.account_number = $2
`

type GetAccountByScopeAndNumberParams struct {
	ScopeID       int64
	AccountNumber sql.NullInt64
}

type GetAccountByScopeAndNumberRow struct {
	AccountNumber sql.NullInt64
	AccountName   string
	OriginID      int16
	IsWatchOnly   bool
	CreatedAt     time.Time
	Purpose       int64
	CoinType      int64
}

// Returns a single account by scope id and account number.
func (q *Queries) GetAccountByScopeAndNumber(ctx context.Context, arg GetAccountByScopeAndNumberParams) (GetAccountByScopeAndNumberRow, error) {
	row := q.queryRow(ctx, q.getAccountByScopeAndNumberStmt, GetAccountByScopeAndNumber, arg.ScopeID, arg.AccountNumber)
	var i GetAccountByScopeAndNumberRow
	err := row.Scan(
		&i.AccountNumber,
		&i.AccountName,
		&i.OriginID,
		&i.IsWatchOnly,
		&i.CreatedAt,
		&i.Purpose,
		&i.CoinType,
	)
	return i, err
}

const GetAccountByWalletScopeAndName = `-- name: GetAccountByWalletScopeAndName :one
SELECT
    a.account_number,
    a.account_name,
    a.origin_id,
    a.is_watch_only,
    a.created_at,
    ks.purpose,
    ks.coin_type
FROM accounts AS a
INNER JOIN key_scopes AS ks ON a.scope_id = ks.id
WHERE
    ks.wallet_id = $1
    AND ks.purpose = $2
    AND ks.coin_type = $3
    AND a.account_name = $4
`

type GetAccountByWalletScopeAndNameParams struct {
	WalletID    int64
	Purpose     int64
	CoinType    int64
	AccountName string
}

type GetAccountByWalletScopeAndNameRow struct {
	AccountNumber sql.NullInt64
	AccountName   string
	OriginID      int16
	IsWatchOnly   bool
	CreatedAt     time.Time
	Purpose       int64
	CoinType      int64
}

// Returns a single account by wallet id, scope tuple, and account name.
func (q *Queries) GetAccountByWalletScopeAndName(ctx context.Context, arg GetAccountByWalletScopeAndNameParams) (GetAccountByWalletScopeAndNameRow, error) {
	row := q.queryRow(ctx, q.getAccountByWalletScopeAndNameStmt, GetAccountByWalletScopeAndName,
		arg.WalletID,
		arg.Purpose,
		arg.CoinType,
		arg.AccountName,
	)
	var i GetAccountByWalletScopeAndNameRow
	err := row.Scan(
		&i.AccountNumber,
		&i.AccountName,
		&i.OriginID,
		&i.IsWatchOnly,
		&i.CreatedAt,
		&i.Purpose,
		&i.CoinType,
	)
	return i, err
}

const GetAccountByWalletScopeAndNumber = `-- name: GetAccountByWalletScopeAndNumber :one
SELECT
    a.account_number,
    a.account_name,
    a.origin_id,
    a.is_watch_only,
    a.created_at,
    ks.purpose,
    ks.coin_type
FROM accounts AS a
INNER JOIN key_scopes AS ks ON a.scope_id = ks.id
WHERE
    ks.wallet_id = $1
    AND ks.purpose = $2
    AND ks.coin_type = $3
    AND a.account_number = $4
`

type GetAccountByWalletScopeAndNumberParams struct {
	WalletID      int64
	Purpose       int64
	CoinType      int64
	AccountNumber sql.NullInt64
}

type GetAccountByWalletScopeAndNumberRow struct {
	AccountNumber sql.NullInt64
	AccountName   string
	OriginID      int16
	IsWatchOnly   bool
	CreatedAt     time.Time
	Purpose       int64
	CoinType      int64
}

// Returns a single account by wallet id, scope tuple, and account number.
func (q *Queries) GetAccountByWalletScopeAndNumber(ctx context.Context, arg GetAccountByWalletScopeAndNumberParams) (GetAccountByWalletScopeAndNumberRow, error) {
	row := q.queryRow(ctx, q.getAccountByWalletScopeAndNumberStmt, GetAccountByWalletScopeAndNumber,
		arg.WalletID,
		arg.Purpose,
		arg.CoinType,
		arg.AccountNumber,
	)
	var i GetAccountByWalletScopeAndNumberRow
	err := row.Scan(
		&i.AccountNumber,
		&i.AccountName,
		&i.OriginID,
		&i.IsWatchOnly,
		&i.CreatedAt,
		&i.Purpose,
		&i.CoinType,
	)
	return i, err
}

const GetAccountPropsById = `-- name: GetAccountPropsById :one
SELECT
    a.account_number,
    a.account_name,
    a.origin_id,
    a.encrypted_public_key,
    a.master_fingerprint,
    a.is_watch_only,
    a.created_at,
    ks.purpose,
    ks.coin_type,
    ks.internal_type_id,
    ks.external_type_id
FROM accounts AS a
INNER JOIN key_scopes AS ks ON a.scope_id = ks.id
WHERE a.id = $1
`

type GetAccountPropsByIdRow struct {
	AccountNumber      sql.NullInt64
	AccountName        string
	OriginID           int16
	EncryptedPublicKey []byte
	MasterFingerprint  sql.NullInt64
	IsWatchOnly        bool
	CreatedAt          time.Time
	Purpose            int64
	CoinType           int64
	InternalTypeID     int16
	ExternalTypeID     int16
}

// Returns full account properties by account id.
func (q *Queries) GetAccountPropsById(ctx context.Context, id int64) (GetAccountPropsByIdRow, error) {
	row := q.queryRow(ctx, q.getAccountPropsByIdStmt, GetAccountPropsById, id)
	var i GetAccountPropsByIdRow
	err := row.Scan(
		&i.AccountNumber,
		&i.AccountName,
		&i.OriginID,
		&i.EncryptedPublicKey,
		&i.MasterFingerprint,
		&i.IsWatchOnly,
		&i.CreatedAt,
		&i.Purpose,
		&i.CoinType,
		&i.InternalTypeID,
		&i.ExternalTypeID,
	)
	return i, err
}

const ListAccountsByScope = `-- name: ListAccountsByScope :many
SELECT
    a.account_number,
    a.account_name,
    a.origin_id,
    a.is_watch_only,
    a.created_at,
    ks.purpose,
    ks.coin_type
FROM accounts AS a
INNER JOIN key_scopes AS ks ON a.scope_id = ks.id
WHERE a.scope_id = $1
ORDER BY a.account_number NULLS LAST
`

type ListAccountsByScopeRow struct {
	AccountNumber sql.NullInt64
	AccountName   string
	OriginID      int16
	IsWatchOnly   bool
	CreatedAt     time.Time
	Purpose       int64
	CoinType      int64
}

// Lists all accounts in a scope, ordered by account number. Imported accounts
// (with NULL account_number) appear last.
func (q *Queries) ListAccountsByScope(ctx context.Context, scopeID int64) ([]ListAccountsByScopeRow, error) {
	rows, err := q.query(ctx, q.listAccountsByScopeStmt, ListAccountsByScope, scopeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountsByScopeRow
	for rows.Next() {
		var i ListAccountsByScopeRow
		if err := rows.Scan(
			&i.AccountNumber,
			&i.AccountName,
			&i.OriginID,
			&i.IsWatchOnly,
			&i.CreatedAt,
			&i.Purpose,
			&i.CoinType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAccountsByWallet = `-- name: ListAccountsByWallet :many
SELECT
    a.account_number,
    a.account_name,
    a.origin_id,
    a.is_watch_only,
    a.created_at,
    ks.purpose,
    ks.coin_type
FROM accounts AS a
INNER JOIN key_scopes AS ks ON a.scope_id = ks.id
WHERE ks.wallet_id = $1
ORDER BY a.account_number NULLS LAST
`

type ListAccountsByWalletRow struct {
	AccountNumber sql.NullInt64
	AccountName   string
	OriginID      int16
	IsWatchOnly   bool
	CreatedAt     time.Time
	Purpose       int64
	CoinType      int64
}

// Lists all accounts for a wallet, ordered by account number. Imported
// accounts (with NULL account_number) appear last.
func (q *Queries) ListAccountsByWallet(ctx context.Context, walletID int64) ([]ListAccountsByWalletRow, error) {
	rows, err := q.query(ctx, q.listAccountsByWalletStmt, ListAccountsByWallet, walletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountsByWalletRow
	for rows.Next() {
		var i ListAccountsByWalletRow
		if err := rows.Scan(
			&i.AccountNumber,
			&i.AccountName,
			&i.OriginID,
			&i.IsWatchOnly,
			&i.CreatedAt,
			&i.Purpose,
			&i.CoinType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAccountsByWalletAndName = `-- name: ListAccountsByWalletAndName :many
SELECT
    a.account_number,
    a.account_name,
    a.origin_id,
    a.is_watch_only,
    a.created_at,
    ks.purpose,
    ks.coin_type
FROM accounts AS a
INNER JOIN key_scopes AS ks ON a.scope_id = ks.id
WHERE ks.wallet_id = $1 AND a.account_name = $2
ORDER BY a.account_number NULLS LAST
`

type ListAccountsByWalletAndNameParams struct {
	WalletID    int64
	AccountName string
}

type ListAccountsByWalletAndNameRow struct {
	AccountNumber sql.NullInt64
	AccountName   string
	OriginID      int16
	IsWatchOnly   bool
	CreatedAt     time.Time
	Purpose       int64
	CoinType      int64
}

// Lists all accounts for a wallet filtered by account name, ordered by account
// number. Imported accounts (with NULL account_number) appear last.
func (q *Queries) ListAccountsByWalletAndName(ctx context.Context, arg ListAccountsByWalletAndNameParams) ([]ListAccountsByWalletAndNameRow, error) {
	rows, err := q.query(ctx, q.listAccountsByWalletAndNameStmt, ListAccountsByWalletAndName, arg.WalletID, arg.AccountName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountsByWalletAndNameRow
	for rows.Next() {
		var i ListAccountsByWalletAndNameRow
		if err := rows.Scan(
			&i.AccountNumber,
			&i.AccountName,
			&i.OriginID,
			&i.IsWatchOnly,
			&i.CreatedAt,
			&i.Purpose,
			&i.CoinType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAccountsByWalletScope = `-- name: ListAccountsByWalletScope :many
SELECT
    a.account_number,
    a.account_name,
    a.origin_id,
    a.is_watch_only,
    a.created_at,
    ks.purpose,
    ks.coin_type
FROM accounts AS a
INNER JOIN key_scopes AS ks ON a.scope_id = ks.id
WHERE
    ks.wallet_id = $1
    AND ks.purpose = $2
    AND ks.coin_type = $3
ORDER BY a.account_number NULLS LAST
`

type ListAccountsByWalletScopeParams struct {
	WalletID int64
	Purpose  int64
	CoinType int64
}

type ListAccountsByWalletScopeRow struct {
	AccountNumber sql.NullInt64
	AccountName   string
	OriginID      int16
	IsWatchOnly   bool
	CreatedAt     time.Time
	Purpose       int64
	CoinType      int64
}

// Lists all accounts for a wallet and scope tuple, ordered by account number.
// Imported accounts (with NULL account_number) appear last.
func (q *Queries) ListAccountsByWalletScope(ctx context.Context, arg ListAccountsByWalletScopeParams) ([]ListAccountsByWalletScopeRow, error) {
	rows, err := q.query(ctx, q.listAccountsByWalletScopeStmt, ListAccountsByWalletScope, arg.WalletID, arg.Purpose, arg.CoinType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountsByWalletScopeRow
	for rows.Next() {
		var i ListAccountsByWalletScopeRow
		if err := rows.Scan(
			&i.AccountNumber,
			&i.AccountName,
			&i.OriginID,
			&i.IsWatchOnly,
			&i.CreatedAt,
			&i.Purpose,
			&i.CoinType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateAccountNameByWalletScopeAndName = `-- name: UpdateAccountNameByWalletScopeAndName :execrows
UPDATE accounts
SET account_name = $1
WHERE
    scope_id IN (
        SELECT id
        FROM key_scopes
        WHERE
            wallet_id = $2
            AND purpose = $3
            AND coin_type = $4
    )
    AND account_name = $5
`

type UpdateAccountNameByWalletScopeAndNameParams struct {
	NewName  string
	WalletID int64
	Purpose  int64
	CoinType int64
	OldName  string
}

// Renames an account identified by wallet id, scope tuple, and current account name.
func (q *Queries) UpdateAccountNameByWalletScopeAndName(ctx context.Context, arg UpdateAccountNameByWalletScopeAndNameParams) (int64, error) {
	result, err := q.exec(ctx, q.updateAccountNameByWalletScopeAndNameStmt, UpdateAccountNameByWalletScopeAndName,
		arg.NewName,
		arg.WalletID,
		arg.Purpose,
		arg.CoinType,
		arg.OldName,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const UpdateAccountNameByWalletScopeAndNumber = `-- name: UpdateAccountNameByWalletScopeAndNumber :execrows
UPDATE accounts
SET account_name = $1
WHERE
    scope_id IN (
        SELECT id
        FROM key_scopes
        WHERE
            wallet_id = $2
            AND purpose = $3
            AND coin_type = $4
    )
    AND account_number = $5
`

type UpdateAccountNameByWalletScopeAndNumberParams struct {
	NewName       string
	WalletID      int64
	Purpose       int64
	CoinType      int64
	AccountNumber sql.NullInt64
}

// Renames an account identified by wallet id, scope tuple, and account number.
func (q *Queries) UpdateAccountNameByWalletScopeAndNumber(ctx context.Context, arg UpdateAccountNameByWalletScopeAndNumberParams) (int64, error) {
	result, err := q.exec(ctx, q.updateAccountNameByWalletScopeAndNumberStmt, UpdateAccountNameByWalletScopeAndNumber,
		arg.NewName,
		arg.WalletID,
		arg.Purpose,
		arg.CoinType,
		arg.AccountNumber,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
