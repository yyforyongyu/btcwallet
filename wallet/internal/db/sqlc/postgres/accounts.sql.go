// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: accounts.sql

package sqlcpg

import (
	"context"
	"database/sql"
	"time"
)

const CreateAccountSecret = `-- name: CreateAccountSecret :exec
INSERT INTO account_secrets (
    account_id,
    encrypted_private_key
) VALUES (
    $1, $2
)
`

type CreateAccountSecretParams struct {
	AccountID           int64
	EncryptedPrivateKey []byte
}

// Inserts the encrypted private key material for an account.
func (q *Queries) CreateAccountSecret(ctx context.Context, arg CreateAccountSecretParams) error {
	_, err := q.exec(ctx, q.createAccountSecretStmt, CreateAccountSecret, arg.AccountID, arg.EncryptedPrivateKey)
	return err
}

const CreateDerivedAccount = `-- name: CreateDerivedAccount :one
INSERT INTO accounts (
    scope_id,
    account_number,
    account_name,
    origin_id,
    encrypted_public_key,
    master_fingerprint,
    is_watch_only
)
VALUES (
    $1,
    (
        SELECT coalesce(max(account_number), -1) + 1
        FROM accounts
        WHERE scope_id = $1
    ),
    $2, $3, $4, $5, $6
)
RETURNING id, account_number, created_at
`

type CreateDerivedAccountParams struct {
	ScopeID            int64
	AccountName        string
	OriginID           int16
	EncryptedPublicKey []byte
	MasterFingerprint  sql.NullInt64
	IsWatchOnly        bool
}

type CreateDerivedAccountRow struct {
	ID            int64
	AccountNumber sql.NullInt64
	CreatedAt     time.Time
}

// Creates a new derived account under the given scope, computing the next
// account number atomically. The caller MUST call LockAccountScope first
// to acquire the advisory lock and prevent race conditions.
// See LockAccountScope comments for why this is a separate statement.
func (q *Queries) CreateDerivedAccount(ctx context.Context, arg CreateDerivedAccountParams) (CreateDerivedAccountRow, error) {
	row := q.queryRow(ctx, q.createDerivedAccountStmt, CreateDerivedAccount,
		arg.ScopeID,
		arg.AccountName,
		arg.OriginID,
		arg.EncryptedPublicKey,
		arg.MasterFingerprint,
		arg.IsWatchOnly,
	)
	var i CreateDerivedAccountRow
	err := row.Scan(&i.ID, &i.AccountNumber, &i.CreatedAt)
	return i, err
}

const CreateDerivedAccountWithNumber = `-- name: CreateDerivedAccountWithNumber :one
INSERT INTO accounts (
    scope_id,
    account_number,
    account_name,
    origin_id,
    is_watch_only
)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, account_number, created_at
`

type CreateDerivedAccountWithNumberParams struct {
	ScopeID       int64
	AccountNumber sql.NullInt64
	AccountName   string
	OriginID      int16
	IsWatchOnly   bool
}

type CreateDerivedAccountWithNumberRow struct {
	ID            int64
	AccountNumber sql.NullInt64
	CreatedAt     time.Time
}

// Test-only: Creates a derived account with a specific account number.
// Used for testing account number overflow without creating billions of accounts.
func (q *Queries) CreateDerivedAccountWithNumber(ctx context.Context, arg CreateDerivedAccountWithNumberParams) (CreateDerivedAccountWithNumberRow, error) {
	row := q.queryRow(ctx, q.createDerivedAccountWithNumberStmt, CreateDerivedAccountWithNumber,
		arg.ScopeID,
		arg.AccountNumber,
		arg.AccountName,
		arg.OriginID,
		arg.IsWatchOnly,
	)
	var i CreateDerivedAccountWithNumberRow
	err := row.Scan(&i.ID, &i.AccountNumber, &i.CreatedAt)
	return i, err
}

const CreateImportedAccount = `-- name: CreateImportedAccount :one
INSERT INTO accounts (
    scope_id,
    account_number,
    account_name,
    origin_id,
    encrypted_public_key,
    master_fingerprint,
    is_watch_only
)
VALUES ($1, NULL, $2, $3, $4, $5, $6)
RETURNING id, created_at
`

type CreateImportedAccountParams struct {
	ScopeID            int64
	AccountName        string
	OriginID           int16
	EncryptedPublicKey []byte
	MasterFingerprint  sql.NullInt64
	IsWatchOnly        bool
}

type CreateImportedAccountRow struct {
	ID        int64
	CreatedAt time.Time
}

// Creates a new imported account under the given scope with NULL account
// number. Imported accounts don't follow BIP44 derivation, so they don't need
// a sequential account number.
func (q *Queries) CreateImportedAccount(ctx context.Context, arg CreateImportedAccountParams) (CreateImportedAccountRow, error) {
	row := q.queryRow(ctx, q.createImportedAccountStmt, CreateImportedAccount,
		arg.ScopeID,
		arg.AccountName,
		arg.OriginID,
		arg.EncryptedPublicKey,
		arg.MasterFingerprint,
		arg.IsWatchOnly,
	)
	var i CreateImportedAccountRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const GetAccountByScopeAndName = `-- name: GetAccountByScopeAndName :one
SELECT
    a.id,
    a.account_number,
    a.account_name,
    a.origin_id,
    a.is_watch_only,
    a.created_at,
    ks.purpose,
    ks.coin_type,
    a.next_external_index AS external_key_count,
    a.next_internal_index AS internal_key_count,
    count(*) FILTER (WHERE addr.address_branch IS NULL AND addr.id IS NOT NULL) AS imported_key_count
FROM accounts AS a
INNER JOIN key_scopes AS ks ON a.scope_id = ks.id
LEFT JOIN addresses AS addr ON a.id = addr.account_id
WHERE a.scope_id = $1 AND a.account_name = $2
GROUP BY a.id, ks.id
`

type GetAccountByScopeAndNameParams struct {
	ScopeID     int64
	AccountName string
}

type GetAccountByScopeAndNameRow struct {
	ID               int64
	AccountNumber    sql.NullInt64
	AccountName      string
	OriginID         int16
	IsWatchOnly      bool
	CreatedAt        time.Time
	Purpose          int64
	CoinType         int64
	ExternalKeyCount int64
	InternalKeyCount int64
	ImportedKeyCount int64
}

// Returns a single account by scope id and account name.
func (q *Queries) GetAccountByScopeAndName(ctx context.Context, arg GetAccountByScopeAndNameParams) (GetAccountByScopeAndNameRow, error) {
	row := q.queryRow(ctx, q.getAccountByScopeAndNameStmt, GetAccountByScopeAndName, arg.ScopeID, arg.AccountName)
	var i GetAccountByScopeAndNameRow
	err := row.Scan(
		&i.ID,
		&i.AccountNumber,
		&i.AccountName,
		&i.OriginID,
		&i.IsWatchOnly,
		&i.CreatedAt,
		&i.Purpose,
		&i.CoinType,
		&i.ExternalKeyCount,
		&i.InternalKeyCount,
		&i.ImportedKeyCount,
	)
	return i, err
}

const GetAccountByScopeAndNumber = `-- name: GetAccountByScopeAndNumber :one
SELECT
    a.id,
    a.account_number,
    a.account_name,
    a.origin_id,
    a.is_watch_only,
    a.created_at,
    ks.purpose,
    ks.coin_type,
    a.next_external_index AS external_key_count,
    a.next_internal_index AS internal_key_count,
    count(*) FILTER (WHERE addr.address_branch IS NULL AND addr.id IS NOT NULL) AS imported_key_count
FROM accounts AS a
INNER JOIN key_scopes AS ks ON a.scope_id = ks.id
LEFT JOIN addresses AS addr ON a.id = addr.account_id
WHERE a.scope_id = $1 AND a.account_number = $2
GROUP BY a.id, ks.id
`

type GetAccountByScopeAndNumberParams struct {
	ScopeID       int64
	AccountNumber sql.NullInt64
}

type GetAccountByScopeAndNumberRow struct {
	ID               int64
	AccountNumber    sql.NullInt64
	AccountName      string
	OriginID         int16
	IsWatchOnly      bool
	CreatedAt        time.Time
	Purpose          int64
	CoinType         int64
	ExternalKeyCount int64
	InternalKeyCount int64
	ImportedKeyCount int64
}

// Returns a single account by scope id and account number.
func (q *Queries) GetAccountByScopeAndNumber(ctx context.Context, arg GetAccountByScopeAndNumberParams) (GetAccountByScopeAndNumberRow, error) {
	row := q.queryRow(ctx, q.getAccountByScopeAndNumberStmt, GetAccountByScopeAndNumber, arg.ScopeID, arg.AccountNumber)
	var i GetAccountByScopeAndNumberRow
	err := row.Scan(
		&i.ID,
		&i.AccountNumber,
		&i.AccountName,
		&i.OriginID,
		&i.IsWatchOnly,
		&i.CreatedAt,
		&i.Purpose,
		&i.CoinType,
		&i.ExternalKeyCount,
		&i.InternalKeyCount,
		&i.ImportedKeyCount,
	)
	return i, err
}

const GetAccountByWalletScopeAndName = `-- name: GetAccountByWalletScopeAndName :one
SELECT
    a.id,
    a.account_number,
    a.account_name,
    a.origin_id,
    a.is_watch_only,
    a.created_at,
    ks.purpose,
    ks.coin_type,
    a.next_external_index AS external_key_count,
    a.next_internal_index AS internal_key_count,
    count(*) FILTER (WHERE addr.address_branch IS NULL AND addr.id IS NOT NULL) AS imported_key_count
FROM accounts AS a
INNER JOIN key_scopes AS ks ON a.scope_id = ks.id
LEFT JOIN addresses AS addr ON a.id = addr.account_id
WHERE
    ks.wallet_id = $1
    AND ks.purpose = $2
    AND ks.coin_type = $3
    AND a.account_name = $4
GROUP BY a.id, ks.id
`

type GetAccountByWalletScopeAndNameParams struct {
	WalletID    int64
	Purpose     int64
	CoinType    int64
	AccountName string
}

type GetAccountByWalletScopeAndNameRow struct {
	ID               int64
	AccountNumber    sql.NullInt64
	AccountName      string
	OriginID         int16
	IsWatchOnly      bool
	CreatedAt        time.Time
	Purpose          int64
	CoinType         int64
	ExternalKeyCount int64
	InternalKeyCount int64
	ImportedKeyCount int64
}

// Returns a single account by wallet id, scope tuple, and account name.
func (q *Queries) GetAccountByWalletScopeAndName(ctx context.Context, arg GetAccountByWalletScopeAndNameParams) (GetAccountByWalletScopeAndNameRow, error) {
	row := q.queryRow(ctx, q.getAccountByWalletScopeAndNameStmt, GetAccountByWalletScopeAndName,
		arg.WalletID,
		arg.Purpose,
		arg.CoinType,
		arg.AccountName,
	)
	var i GetAccountByWalletScopeAndNameRow
	err := row.Scan(
		&i.ID,
		&i.AccountNumber,
		&i.AccountName,
		&i.OriginID,
		&i.IsWatchOnly,
		&i.CreatedAt,
		&i.Purpose,
		&i.CoinType,
		&i.ExternalKeyCount,
		&i.InternalKeyCount,
		&i.ImportedKeyCount,
	)
	return i, err
}

const GetAccountByWalletScopeAndNumber = `-- name: GetAccountByWalletScopeAndNumber :one
SELECT
    a.id,
    a.account_number,
    a.account_name,
    a.origin_id,
    a.is_watch_only,
    a.created_at,
    ks.purpose,
    ks.coin_type,
    a.next_external_index AS external_key_count,
    a.next_internal_index AS internal_key_count,
    count(*) FILTER (WHERE addr.address_branch IS NULL AND addr.id IS NOT NULL) AS imported_key_count
FROM accounts AS a
INNER JOIN key_scopes AS ks ON a.scope_id = ks.id
LEFT JOIN addresses AS addr ON a.id = addr.account_id
WHERE
    ks.wallet_id = $1
    AND ks.purpose = $2
    AND ks.coin_type = $3
    AND a.account_number = $4
GROUP BY a.id, ks.id
`

type GetAccountByWalletScopeAndNumberParams struct {
	WalletID      int64
	Purpose       int64
	CoinType      int64
	AccountNumber sql.NullInt64
}

type GetAccountByWalletScopeAndNumberRow struct {
	ID               int64
	AccountNumber    sql.NullInt64
	AccountName      string
	OriginID         int16
	IsWatchOnly      bool
	CreatedAt        time.Time
	Purpose          int64
	CoinType         int64
	ExternalKeyCount int64
	InternalKeyCount int64
	ImportedKeyCount int64
}

// Returns a single account by wallet id, scope tuple, and account number.
func (q *Queries) GetAccountByWalletScopeAndNumber(ctx context.Context, arg GetAccountByWalletScopeAndNumberParams) (GetAccountByWalletScopeAndNumberRow, error) {
	row := q.queryRow(ctx, q.getAccountByWalletScopeAndNumberStmt, GetAccountByWalletScopeAndNumber,
		arg.WalletID,
		arg.Purpose,
		arg.CoinType,
		arg.AccountNumber,
	)
	var i GetAccountByWalletScopeAndNumberRow
	err := row.Scan(
		&i.ID,
		&i.AccountNumber,
		&i.AccountName,
		&i.OriginID,
		&i.IsWatchOnly,
		&i.CreatedAt,
		&i.Purpose,
		&i.CoinType,
		&i.ExternalKeyCount,
		&i.InternalKeyCount,
		&i.ImportedKeyCount,
	)
	return i, err
}

const GetAccountPropsById = `-- name: GetAccountPropsById :one
SELECT
    a.account_number,
    a.account_name,
    a.origin_id,
    a.encrypted_public_key,
    a.master_fingerprint,
    a.is_watch_only,
    a.created_at,
    ks.purpose,
    ks.coin_type,
    ks.internal_type_id,
    ks.external_type_id,
    a.next_external_index AS external_key_count,
    a.next_internal_index AS internal_key_count,
    count(*) FILTER (WHERE addr.address_branch IS NULL AND addr.id IS NOT NULL) AS imported_key_count
FROM accounts AS a
INNER JOIN key_scopes AS ks ON a.scope_id = ks.id
LEFT JOIN addresses AS addr ON a.id = addr.account_id
WHERE a.id = $1
GROUP BY a.id, ks.id
`

type GetAccountPropsByIdRow struct {
	AccountNumber      sql.NullInt64
	AccountName        string
	OriginID           int16
	EncryptedPublicKey []byte
	MasterFingerprint  sql.NullInt64
	IsWatchOnly        bool
	CreatedAt          time.Time
	Purpose            int64
	CoinType           int64
	InternalTypeID     int16
	ExternalTypeID     int16
	ExternalKeyCount   int64
	InternalKeyCount   int64
	ImportedKeyCount   int64
}

// Returns full account properties by account id.
func (q *Queries) GetAccountPropsById(ctx context.Context, id int64) (GetAccountPropsByIdRow, error) {
	row := q.queryRow(ctx, q.getAccountPropsByIdStmt, GetAccountPropsById, id)
	var i GetAccountPropsByIdRow
	err := row.Scan(
		&i.AccountNumber,
		&i.AccountName,
		&i.OriginID,
		&i.EncryptedPublicKey,
		&i.MasterFingerprint,
		&i.IsWatchOnly,
		&i.CreatedAt,
		&i.Purpose,
		&i.CoinType,
		&i.InternalTypeID,
		&i.ExternalTypeID,
		&i.ExternalKeyCount,
		&i.InternalKeyCount,
		&i.ImportedKeyCount,
	)
	return i, err
}

const GetAndIncrementNextExternalIndex = `-- name: GetAndIncrementNextExternalIndex :one
UPDATE accounts
SET next_external_index = next_external_index + 1
WHERE id = $1
RETURNING (next_external_index - 1)::BIGINT AS address_index
`

// Atomically gets the next external address index and increments the counter.
// Returns the current index value (before incrementing) for the address derivation.
func (q *Queries) GetAndIncrementNextExternalIndex(ctx context.Context, id int64) (int64, error) {
	row := q.queryRow(ctx, q.getAndIncrementNextExternalIndexStmt, GetAndIncrementNextExternalIndex, id)
	var address_index int64
	err := row.Scan(&address_index)
	return address_index, err
}

const GetAndIncrementNextInternalIndex = `-- name: GetAndIncrementNextInternalIndex :one
UPDATE accounts
SET next_internal_index = next_internal_index + 1
WHERE id = $1
RETURNING (next_internal_index - 1)::BIGINT AS address_index
`

// Atomically gets the next internal/change address index and increments the counter.
// Returns the current index value (before incrementing) for the address derivation.
func (q *Queries) GetAndIncrementNextInternalIndex(ctx context.Context, id int64) (int64, error) {
	row := q.queryRow(ctx, q.getAndIncrementNextInternalIndexStmt, GetAndIncrementNextInternalIndex, id)
	var address_index int64
	err := row.Scan(&address_index)
	return address_index, err
}

const ListAccountsByScope = `-- name: ListAccountsByScope :many
SELECT
    a.id,
    a.account_number,
    a.account_name,
    a.origin_id,
    a.is_watch_only,
    a.created_at,
    ks.purpose,
    ks.coin_type,
    a.next_external_index AS external_key_count,
    a.next_internal_index AS internal_key_count,
    count(*) FILTER (WHERE addr.address_branch IS NULL AND addr.id IS NOT NULL) AS imported_key_count
FROM accounts AS a
INNER JOIN key_scopes AS ks ON a.scope_id = ks.id
LEFT JOIN addresses AS addr ON a.id = addr.account_id
WHERE a.scope_id = $1
GROUP BY a.id, ks.id
ORDER BY a.account_number NULLS LAST
`

type ListAccountsByScopeRow struct {
	ID               int64
	AccountNumber    sql.NullInt64
	AccountName      string
	OriginID         int16
	IsWatchOnly      bool
	CreatedAt        time.Time
	Purpose          int64
	CoinType         int64
	ExternalKeyCount int64
	InternalKeyCount int64
	ImportedKeyCount int64
}

// Lists all accounts in a scope, ordered by account number. Imported accounts
// (with NULL account_number) appear last.
func (q *Queries) ListAccountsByScope(ctx context.Context, scopeID int64) ([]ListAccountsByScopeRow, error) {
	rows, err := q.query(ctx, q.listAccountsByScopeStmt, ListAccountsByScope, scopeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountsByScopeRow
	for rows.Next() {
		var i ListAccountsByScopeRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountNumber,
			&i.AccountName,
			&i.OriginID,
			&i.IsWatchOnly,
			&i.CreatedAt,
			&i.Purpose,
			&i.CoinType,
			&i.ExternalKeyCount,
			&i.InternalKeyCount,
			&i.ImportedKeyCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAccountsByWallet = `-- name: ListAccountsByWallet :many
SELECT
    a.id,
    a.account_number,
    a.account_name,
    a.origin_id,
    a.is_watch_only,
    a.created_at,
    ks.purpose,
    ks.coin_type,
    a.next_external_index AS external_key_count,
    a.next_internal_index AS internal_key_count,
    count(*) FILTER (WHERE addr.address_branch IS NULL AND addr.id IS NOT NULL) AS imported_key_count
FROM accounts AS a
INNER JOIN key_scopes AS ks ON a.scope_id = ks.id
LEFT JOIN addresses AS addr ON a.id = addr.account_id
WHERE ks.wallet_id = $1
GROUP BY a.id, ks.id
ORDER BY a.account_number NULLS LAST
`

type ListAccountsByWalletRow struct {
	ID               int64
	AccountNumber    sql.NullInt64
	AccountName      string
	OriginID         int16
	IsWatchOnly      bool
	CreatedAt        time.Time
	Purpose          int64
	CoinType         int64
	ExternalKeyCount int64
	InternalKeyCount int64
	ImportedKeyCount int64
}

// Lists all accounts for a wallet, ordered by account number. Imported
// accounts (with NULL account_number) appear last.
func (q *Queries) ListAccountsByWallet(ctx context.Context, walletID int64) ([]ListAccountsByWalletRow, error) {
	rows, err := q.query(ctx, q.listAccountsByWalletStmt, ListAccountsByWallet, walletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountsByWalletRow
	for rows.Next() {
		var i ListAccountsByWalletRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountNumber,
			&i.AccountName,
			&i.OriginID,
			&i.IsWatchOnly,
			&i.CreatedAt,
			&i.Purpose,
			&i.CoinType,
			&i.ExternalKeyCount,
			&i.InternalKeyCount,
			&i.ImportedKeyCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAccountsByWalletAndName = `-- name: ListAccountsByWalletAndName :many
SELECT
    a.id,
    a.account_number,
    a.account_name,
    a.origin_id,
    a.is_watch_only,
    a.created_at,
    ks.purpose,
    ks.coin_type,
    a.next_external_index AS external_key_count,
    a.next_internal_index AS internal_key_count,
    count(*) FILTER (WHERE addr.address_branch IS NULL AND addr.id IS NOT NULL) AS imported_key_count
FROM accounts AS a
INNER JOIN key_scopes AS ks ON a.scope_id = ks.id
LEFT JOIN addresses AS addr ON a.id = addr.account_id
WHERE ks.wallet_id = $1 AND a.account_name = $2
GROUP BY a.id, ks.id
ORDER BY a.account_number NULLS LAST
`

type ListAccountsByWalletAndNameParams struct {
	WalletID    int64
	AccountName string
}

type ListAccountsByWalletAndNameRow struct {
	ID               int64
	AccountNumber    sql.NullInt64
	AccountName      string
	OriginID         int16
	IsWatchOnly      bool
	CreatedAt        time.Time
	Purpose          int64
	CoinType         int64
	ExternalKeyCount int64
	InternalKeyCount int64
	ImportedKeyCount int64
}

// Lists all accounts for a wallet filtered by account name, ordered by account
// number. Imported accounts (with NULL account_number) appear last.
func (q *Queries) ListAccountsByWalletAndName(ctx context.Context, arg ListAccountsByWalletAndNameParams) ([]ListAccountsByWalletAndNameRow, error) {
	rows, err := q.query(ctx, q.listAccountsByWalletAndNameStmt, ListAccountsByWalletAndName, arg.WalletID, arg.AccountName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountsByWalletAndNameRow
	for rows.Next() {
		var i ListAccountsByWalletAndNameRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountNumber,
			&i.AccountName,
			&i.OriginID,
			&i.IsWatchOnly,
			&i.CreatedAt,
			&i.Purpose,
			&i.CoinType,
			&i.ExternalKeyCount,
			&i.InternalKeyCount,
			&i.ImportedKeyCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAccountsByWalletScope = `-- name: ListAccountsByWalletScope :many
SELECT
    a.id,
    a.account_number,
    a.account_name,
    a.origin_id,
    a.is_watch_only,
    a.created_at,
    ks.purpose,
    ks.coin_type,
    a.next_external_index AS external_key_count,
    a.next_internal_index AS internal_key_count,
    count(*) FILTER (WHERE addr.address_branch IS NULL AND addr.id IS NOT NULL) AS imported_key_count
FROM accounts AS a
INNER JOIN key_scopes AS ks ON a.scope_id = ks.id
LEFT JOIN addresses AS addr ON a.id = addr.account_id
WHERE
    ks.wallet_id = $1
    AND ks.purpose = $2
    AND ks.coin_type = $3
GROUP BY a.id, ks.id
ORDER BY a.account_number NULLS LAST
`

type ListAccountsByWalletScopeParams struct {
	WalletID int64
	Purpose  int64
	CoinType int64
}

type ListAccountsByWalletScopeRow struct {
	ID               int64
	AccountNumber    sql.NullInt64
	AccountName      string
	OriginID         int16
	IsWatchOnly      bool
	CreatedAt        time.Time
	Purpose          int64
	CoinType         int64
	ExternalKeyCount int64
	InternalKeyCount int64
	ImportedKeyCount int64
}

// Lists all accounts for a wallet and scope tuple, ordered by account number.
// Imported accounts (with NULL account_number) appear last.
func (q *Queries) ListAccountsByWalletScope(ctx context.Context, arg ListAccountsByWalletScopeParams) ([]ListAccountsByWalletScopeRow, error) {
	rows, err := q.query(ctx, q.listAccountsByWalletScopeStmt, ListAccountsByWalletScope, arg.WalletID, arg.Purpose, arg.CoinType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAccountsByWalletScopeRow
	for rows.Next() {
		var i ListAccountsByWalletScopeRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountNumber,
			&i.AccountName,
			&i.OriginID,
			&i.IsWatchOnly,
			&i.CreatedAt,
			&i.Purpose,
			&i.CoinType,
			&i.ExternalKeyCount,
			&i.InternalKeyCount,
			&i.ImportedKeyCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const LockAccountScope = `-- name: LockAccountScope :exec
SELECT pg_advisory_xact_lock(hashtextextended('account_scope', $1::BIGINT))
`

// Acquires a transaction-level advisory lock to serialize account creation within a scope.
// The lock is automatically released upon transaction commit or rollback.
// This MUST be called immediately before 'CreateDerivedAccount' within the same transaction.
//
// We explicitly use a two-statement pattern because single-statement CTE/Join
// approaches failed to prevent race conditions during concurrent account generation.
// The following "one-query" strategies were tested and proven unreliable:
//
//  1. CTE with CROSS/INNER JOIN: The PostgreSQL optimizer may evaluate the
//     MAX(account_number) subquery using a snapshot taken before the lock CTE
//     is fully processed, leading to duplicate account numbers.
//
//  2. CTE with OFFSET 0: Designed to force materialization, this still fails to
//     guarantee that the lock is held before the aggregate subquery begins its
//     read operation.
//
//  3. FOR UPDATE in Subqueries: Since FOR UPDATE targets existing rows, it fails
//     to "lock the gap" for new inserts or handle empty tables, allowing
//     concurrent processes to calculate identical MAX() values.
//
// Using two separate calls ensures the application pauses until
// LockAccountScope returns, guaranteeing that the subsequent SELECT MAX()
// operates inside a strictly serialized execution window for that scope.
func (q *Queries) LockAccountScope(ctx context.Context, dollar_1 int64) error {
	_, err := q.exec(ctx, q.lockAccountScopeStmt, LockAccountScope, dollar_1)
	return err
}

const UpdateAccountNameByWalletScopeAndName = `-- name: UpdateAccountNameByWalletScopeAndName :execrows
UPDATE accounts
SET account_name = $1
WHERE
    scope_id IN (
        SELECT id
        FROM key_scopes
        WHERE
            wallet_id = $2
            AND purpose = $3
            AND coin_type = $4
    )
    AND account_name = $5
`

type UpdateAccountNameByWalletScopeAndNameParams struct {
	NewName  string
	WalletID int64
	Purpose  int64
	CoinType int64
	OldName  string
}

// Renames an account identified by wallet id, scope tuple, and current account name.
func (q *Queries) UpdateAccountNameByWalletScopeAndName(ctx context.Context, arg UpdateAccountNameByWalletScopeAndNameParams) (int64, error) {
	result, err := q.exec(ctx, q.updateAccountNameByWalletScopeAndNameStmt, UpdateAccountNameByWalletScopeAndName,
		arg.NewName,
		arg.WalletID,
		arg.Purpose,
		arg.CoinType,
		arg.OldName,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const UpdateAccountNameByWalletScopeAndNumber = `-- name: UpdateAccountNameByWalletScopeAndNumber :execrows
UPDATE accounts
SET account_name = $1
WHERE
    scope_id IN (
        SELECT id
        FROM key_scopes
        WHERE
            wallet_id = $2
            AND purpose = $3
            AND coin_type = $4
    )
    AND account_number = $5
`

type UpdateAccountNameByWalletScopeAndNumberParams struct {
	NewName       string
	WalletID      int64
	Purpose       int64
	CoinType      int64
	AccountNumber sql.NullInt64
}

// Renames an account identified by wallet id, scope tuple, and account number.
func (q *Queries) UpdateAccountNameByWalletScopeAndNumber(ctx context.Context, arg UpdateAccountNameByWalletScopeAndNumberParams) (int64, error) {
	result, err := q.exec(ctx, q.updateAccountNameByWalletScopeAndNumberStmt, UpdateAccountNameByWalletScopeAndNumber,
		arg.NewName,
		arg.WalletID,
		arg.Purpose,
		arg.CoinType,
		arg.AccountNumber,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const UpdateAccountNextExternalIndex = `-- name: UpdateAccountNextExternalIndex :exec
UPDATE accounts
SET next_external_index = $2
WHERE id = $1
`

type UpdateAccountNextExternalIndexParams struct {
	ID                int64
	NextExternalIndex int64
}

// Updates the next_external_index counter for an account. Used in tests
// to set up specific index scenarios.
func (q *Queries) UpdateAccountNextExternalIndex(ctx context.Context, arg UpdateAccountNextExternalIndexParams) error {
	_, err := q.exec(ctx, q.updateAccountNextExternalIndexStmt, UpdateAccountNextExternalIndex, arg.ID, arg.NextExternalIndex)
	return err
}

const UpdateAccountNextInternalIndex = `-- name: UpdateAccountNextInternalIndex :exec
UPDATE accounts
SET next_internal_index = $2
WHERE id = $1
`

type UpdateAccountNextInternalIndexParams struct {
	ID                int64
	NextInternalIndex int64
}

// Updates the next_internal_index counter for an account. Used in tests
// to set up specific index scenarios.
func (q *Queries) UpdateAccountNextInternalIndex(ctx context.Context, arg UpdateAccountNextInternalIndexParams) error {
	_, err := q.exec(ctx, q.updateAccountNextInternalIndexStmt, UpdateAccountNextInternalIndex, arg.ID, arg.NextInternalIndex)
	return err
}
