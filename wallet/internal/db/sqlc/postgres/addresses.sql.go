// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: addresses.sql

package sqlcpg

import (
	"context"
	"database/sql"
	"time"
)

const CreateDerivedAddress = `-- name: CreateDerivedAddress :one
INSERT INTO addresses (
    account_id,
    script_pub_key,
    type_id,
    address_branch,
    address_index,
    pub_key
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, created_at
`

type CreateDerivedAddressParams struct {
	AccountID     int64
	ScriptPubKey  []byte
	TypeID        int16
	AddressBranch sql.NullInt16
	AddressIndex  sql.NullInt64
	PubKey        []byte
}

type CreateDerivedAddressRow struct {
	ID        int64
	CreatedAt time.Time
}

// Creates a derived address with the given index and derived data.
// The index is allocated separately via GetAndIncrementNextExternalIndex
// or GetAndIncrementNextInternalIndex.
func (q *Queries) CreateDerivedAddress(ctx context.Context, arg CreateDerivedAddressParams) (CreateDerivedAddressRow, error) {
	row := q.queryRow(ctx, q.createDerivedAddressStmt, CreateDerivedAddress,
		arg.AccountID,
		arg.ScriptPubKey,
		arg.TypeID,
		arg.AddressBranch,
		arg.AddressIndex,
		arg.PubKey,
	)
	var i CreateDerivedAddressRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const CreateImportedAddress = `-- name: CreateImportedAddress :one
INSERT INTO addresses (
    account_id,
    script_pub_key,
    type_id,
    address_branch,
    address_index,
    pub_key
) VALUES (
    $1, $2, $3, NULL, NULL, $4
)
RETURNING id, created_at
`

type CreateImportedAddressParams struct {
	AccountID    int64
	ScriptPubKey []byte
	TypeID       int16
	PubKey       []byte
}

type CreateImportedAddressRow struct {
	ID        int64
	CreatedAt time.Time
}

// Creates an imported address (no derivation path, has script/pubkey).
func (q *Queries) CreateImportedAddress(ctx context.Context, arg CreateImportedAddressParams) (CreateImportedAddressRow, error) {
	row := q.queryRow(ctx, q.createImportedAddressStmt, CreateImportedAddress,
		arg.AccountID,
		arg.ScriptPubKey,
		arg.TypeID,
		arg.PubKey,
	)
	var i CreateImportedAddressRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const GetAddressByScriptPubKey = `-- name: GetAddressByScriptPubKey :one
SELECT
    a.id,
    a.account_id,
    a.type_id,
    a.address_branch,
    a.address_index,
    a.script_pub_key,
    a.pub_key,
    a.created_at,
    acc.origin_id,
    (s.encrypted_priv_key IS NOT NULL)::BOOLEAN AS has_private_key,
    (s.encrypted_script IS NOT NULL)::BOOLEAN AS has_script
FROM addresses AS a
INNER JOIN accounts AS acc ON a.account_id = acc.id
INNER JOIN key_scopes AS ks ON acc.scope_id = ks.id
LEFT JOIN address_secrets AS s ON a.id = s.address_id
WHERE a.script_pub_key = $1 AND ks.wallet_id = $2
`

type GetAddressByScriptPubKeyParams struct {
	ScriptPubKey []byte
	WalletID     int64
}

type GetAddressByScriptPubKeyRow struct {
	ID            int64
	AccountID     int64
	TypeID        int16
	AddressBranch sql.NullInt16
	AddressIndex  sql.NullInt64
	ScriptPubKey  []byte
	PubKey        []byte
	CreatedAt     time.Time
	OriginID      int16
	HasPrivateKey bool
	HasScript     bool
}

// Retrieves an address by its script pubkey and account wallet.
func (q *Queries) GetAddressByScriptPubKey(ctx context.Context, arg GetAddressByScriptPubKeyParams) (GetAddressByScriptPubKeyRow, error) {
	row := q.queryRow(ctx, q.getAddressByScriptPubKeyStmt, GetAddressByScriptPubKey, arg.ScriptPubKey, arg.WalletID)
	var i GetAddressByScriptPubKeyRow
	err := row.Scan(
		&i.ID,
		&i.AccountID,
		&i.TypeID,
		&i.AddressBranch,
		&i.AddressIndex,
		&i.ScriptPubKey,
		&i.PubKey,
		&i.CreatedAt,
		&i.OriginID,
		&i.HasPrivateKey,
		&i.HasScript,
	)
	return i, err
}

const GetAddressSecret = `-- name: GetAddressSecret :one
SELECT
    a.id AS address_id,
    s.encrypted_priv_key,
    s.encrypted_script
FROM addresses AS a
LEFT JOIN address_secrets AS s ON a.id = s.address_id
WHERE a.id = $1
`

type GetAddressSecretRow struct {
	AddressID        int64
	EncryptedPrivKey []byte
	EncryptedScript  []byte
}

// Retrieves secret information for an address. Uses LEFT JOIN to distinguish:
// - Address exists with secret: returns full row
// - Address exists without secret (watch-only/derived): returns row with NULL secret fields
// - Address does not exist: returns no rows (sql.ErrNoRows)
func (q *Queries) GetAddressSecret(ctx context.Context, id int64) (GetAddressSecretRow, error) {
	row := q.queryRow(ctx, q.getAddressSecretStmt, GetAddressSecret, id)
	var i GetAddressSecretRow
	err := row.Scan(&i.AddressID, &i.EncryptedPrivKey, &i.EncryptedScript)
	return i, err
}

const InsertAddressSecret = `-- name: InsertAddressSecret :exec
INSERT INTO address_secrets (
    address_id,
    encrypted_priv_key,
    encrypted_script
) VALUES (
    $1, $2, $3
)
`

type InsertAddressSecretParams struct {
	AddressID        int64
	EncryptedPrivKey []byte
	EncryptedScript  []byte
}

// Inserts address secret information (private key, script) for imported addresses.
// Not used for derived addresses (their keys are derived from account key).
func (q *Queries) InsertAddressSecret(ctx context.Context, arg InsertAddressSecretParams) error {
	_, err := q.exec(ctx, q.insertAddressSecretStmt, InsertAddressSecret, arg.AddressID, arg.EncryptedPrivKey, arg.EncryptedScript)
	return err
}

const ListAddressesByAccount = `-- name: ListAddressesByAccount :many
SELECT
    a.id,
    a.account_id,
    a.type_id,
    a.address_branch,
    a.address_index,
    a.script_pub_key,
    a.pub_key,
    a.created_at,
    acc.origin_id,
    (s.encrypted_priv_key IS NOT NULL)::BOOLEAN AS has_private_key,
    (s.encrypted_script IS NOT NULL)::BOOLEAN AS has_script
FROM addresses AS a
INNER JOIN accounts AS acc ON a.account_id = acc.id
INNER JOIN key_scopes AS ks ON acc.scope_id = ks.id
LEFT JOIN address_secrets AS s ON a.id = s.address_id
WHERE
    ks.wallet_id = $1 AND ks.purpose = $2 AND ks.coin_type = $3
    AND acc.account_name = $4
ORDER BY a.id
`

type ListAddressesByAccountParams struct {
	WalletID    int64
	Purpose     int64
	CoinType    int64
	AccountName string
}

type ListAddressesByAccountRow struct {
	ID            int64
	AccountID     int64
	TypeID        int16
	AddressBranch sql.NullInt16
	AddressIndex  sql.NullInt64
	ScriptPubKey  []byte
	PubKey        []byte
	CreatedAt     time.Time
	OriginID      int16
	HasPrivateKey bool
	HasScript     bool
}

// Lists all addresses for a given account identified by wallet_id, key scope
// (purpose/coin_type), and account name. Returns all address columns for
// filtering and processing by the application.
func (q *Queries) ListAddressesByAccount(ctx context.Context, arg ListAddressesByAccountParams) ([]ListAddressesByAccountRow, error) {
	rows, err := q.query(ctx, q.listAddressesByAccountStmt, ListAddressesByAccount,
		arg.WalletID,
		arg.Purpose,
		arg.CoinType,
		arg.AccountName,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAddressesByAccountRow
	for rows.Next() {
		var i ListAddressesByAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.AccountID,
			&i.TypeID,
			&i.AddressBranch,
			&i.AddressIndex,
			&i.ScriptPubKey,
			&i.PubKey,
			&i.CreatedAt,
			&i.OriginID,
			&i.HasPrivateKey,
			&i.HasScript,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
