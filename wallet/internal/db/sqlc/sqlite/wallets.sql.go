// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: wallets.sql

package sqlcsqlite

import (
	"context"
	"database/sql"
)

const CreateWallet = `-- name: CreateWallet :one
INSERT INTO wallets (
    wallet_name,
    is_imported,
    manager_version,
    is_watch_only,
    master_pub_params,
    encrypted_crypto_pub_key,
    encrypted_master_hd_pub_key
) VALUES (
    ?, ?, ?, ?, ?, ?, ?
)
RETURNING id
`

type CreateWalletParams struct {
	WalletName              string
	IsImported              bool
	ManagerVersion          int64
	IsWatchOnly             bool
	MasterPubParams         []byte
	EncryptedCryptoPubKey   []byte
	EncryptedMasterHdPubKey []byte
}

func (q *Queries) CreateWallet(ctx context.Context, arg CreateWalletParams) (int64, error) {
	row := q.queryRow(ctx, q.createWalletStmt, CreateWallet,
		arg.WalletName,
		arg.IsImported,
		arg.ManagerVersion,
		arg.IsWatchOnly,
		arg.MasterPubParams,
		arg.EncryptedCryptoPubKey,
		arg.EncryptedMasterHdPubKey,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const GetWalletByID = `-- name: GetWalletByID :one
SELECT
    w.id,
    w.wallet_name,
    w.is_imported,
    w.manager_version,
    w.is_watch_only,
    s.synced_height,
    s.birthday_height,
    s.birthday,
    s.updated_at,
    b_synced.header_hash AS synced_block_hash,
    b_synced.block_timestamp AS synced_block_timestamp,
    b_birthday.header_hash AS birthday_block_hash,
    b_birthday.block_timestamp AS birthday_block_timestamp
FROM wallets AS w
LEFT JOIN wallet_sync_states AS s ON w.id = s.wallet_id
LEFT JOIN blocks AS b_synced ON s.synced_height = b_synced.block_height
LEFT JOIN blocks AS b_birthday ON s.birthday_height = b_birthday.block_height
WHERE w.id = ?
`

type GetWalletByIDRow struct {
	ID                     int64
	WalletName             string
	IsImported             bool
	ManagerVersion         int64
	IsWatchOnly            bool
	SyncedHeight           sql.NullInt64
	BirthdayHeight         sql.NullInt64
	Birthday               sql.NullTime
	UpdatedAt              sql.NullTime
	SyncedBlockHash        []byte
	SyncedBlockTimestamp   sql.NullInt64
	BirthdayBlockHash      []byte
	BirthdayBlockTimestamp sql.NullInt64
}

func (q *Queries) GetWalletByID(ctx context.Context, id int64) (GetWalletByIDRow, error) {
	row := q.queryRow(ctx, q.getWalletByIDStmt, GetWalletByID, id)
	var i GetWalletByIDRow
	err := row.Scan(
		&i.ID,
		&i.WalletName,
		&i.IsImported,
		&i.ManagerVersion,
		&i.IsWatchOnly,
		&i.SyncedHeight,
		&i.BirthdayHeight,
		&i.Birthday,
		&i.UpdatedAt,
		&i.SyncedBlockHash,
		&i.SyncedBlockTimestamp,
		&i.BirthdayBlockHash,
		&i.BirthdayBlockTimestamp,
	)
	return i, err
}

const GetWalletByName = `-- name: GetWalletByName :one
SELECT
    w.id,
    w.wallet_name,
    w.is_imported,
    w.manager_version,
    w.is_watch_only,
    s.synced_height,
    s.birthday_height,
    s.birthday,
    s.updated_at,
    b_synced.header_hash AS synced_block_hash,
    b_synced.block_timestamp AS synced_block_timestamp,
    b_birthday.header_hash AS birthday_block_hash,
    b_birthday.block_timestamp AS birthday_block_timestamp
FROM wallets AS w
LEFT JOIN wallet_sync_states AS s ON w.id = s.wallet_id
LEFT JOIN blocks AS b_synced ON s.synced_height = b_synced.block_height
LEFT JOIN blocks AS b_birthday ON s.birthday_height = b_birthday.block_height
WHERE w.wallet_name = ?
`

type GetWalletByNameRow struct {
	ID                     int64
	WalletName             string
	IsImported             bool
	ManagerVersion         int64
	IsWatchOnly            bool
	SyncedHeight           sql.NullInt64
	BirthdayHeight         sql.NullInt64
	Birthday               sql.NullTime
	UpdatedAt              sql.NullTime
	SyncedBlockHash        []byte
	SyncedBlockTimestamp   sql.NullInt64
	BirthdayBlockHash      []byte
	BirthdayBlockTimestamp sql.NullInt64
}

func (q *Queries) GetWalletByName(ctx context.Context, walletName string) (GetWalletByNameRow, error) {
	row := q.queryRow(ctx, q.getWalletByNameStmt, GetWalletByName, walletName)
	var i GetWalletByNameRow
	err := row.Scan(
		&i.ID,
		&i.WalletName,
		&i.IsImported,
		&i.ManagerVersion,
		&i.IsWatchOnly,
		&i.SyncedHeight,
		&i.BirthdayHeight,
		&i.Birthday,
		&i.UpdatedAt,
		&i.SyncedBlockHash,
		&i.SyncedBlockTimestamp,
		&i.BirthdayBlockHash,
		&i.BirthdayBlockTimestamp,
	)
	return i, err
}

const GetWalletSecrets = `-- name: GetWalletSecrets :one
SELECT
    wallet_id,
    master_priv_params,
    encrypted_crypto_priv_key,
    encrypted_crypto_script_key,
    encrypted_master_hd_priv_key
FROM wallet_secrets
WHERE wallet_id = ?
`

func (q *Queries) GetWalletSecrets(ctx context.Context, walletID int64) (WalletSecret, error) {
	row := q.queryRow(ctx, q.getWalletSecretsStmt, GetWalletSecrets, walletID)
	var i WalletSecret
	err := row.Scan(
		&i.WalletID,
		&i.MasterPrivParams,
		&i.EncryptedCryptoPrivKey,
		&i.EncryptedCryptoScriptKey,
		&i.EncryptedMasterHdPrivKey,
	)
	return i, err
}

const InsertWalletSecrets = `-- name: InsertWalletSecrets :exec
INSERT INTO wallet_secrets (
    wallet_id,
    master_priv_params,
    encrypted_crypto_priv_key,
    encrypted_crypto_script_key,
    encrypted_master_hd_priv_key
) VALUES (
    ?, ?, ?, ?, ?
)
`

type InsertWalletSecretsParams struct {
	WalletID                 int64
	MasterPrivParams         []byte
	EncryptedCryptoPrivKey   []byte
	EncryptedCryptoScriptKey []byte
	EncryptedMasterHdPrivKey []byte
}

func (q *Queries) InsertWalletSecrets(ctx context.Context, arg InsertWalletSecretsParams) error {
	_, err := q.exec(ctx, q.insertWalletSecretsStmt, InsertWalletSecrets,
		arg.WalletID,
		arg.MasterPrivParams,
		arg.EncryptedCryptoPrivKey,
		arg.EncryptedCryptoScriptKey,
		arg.EncryptedMasterHdPrivKey,
	)
	return err
}

const InsertWalletSyncState = `-- name: InsertWalletSyncState :exec
INSERT INTO wallet_sync_states (
    wallet_id,
    synced_height,
    birthday_height,
    birthday,
    updated_at
) VALUES (
    ?, ?, ?, ?, current_timestamp
)
`

type InsertWalletSyncStateParams struct {
	WalletID       int64
	SyncedHeight   sql.NullInt64
	BirthdayHeight sql.NullInt64
	Birthday       sql.NullTime
}

func (q *Queries) InsertWalletSyncState(ctx context.Context, arg InsertWalletSyncStateParams) error {
	_, err := q.exec(ctx, q.insertWalletSyncStateStmt, InsertWalletSyncState,
		arg.WalletID,
		arg.SyncedHeight,
		arg.BirthdayHeight,
		arg.Birthday,
	)
	return err
}

const ListWallets = `-- name: ListWallets :many
SELECT
    w.id,
    w.wallet_name,
    w.is_imported,
    w.manager_version,
    w.is_watch_only,
    s.synced_height,
    s.birthday_height,
    s.birthday,
    s.updated_at,
    b_synced.header_hash AS synced_block_hash,
    b_synced.block_timestamp AS synced_block_timestamp,
    b_birthday.header_hash AS birthday_block_hash,
    b_birthday.block_timestamp AS birthday_block_timestamp
FROM wallets AS w
LEFT JOIN wallet_sync_states AS s ON w.id = s.wallet_id
LEFT JOIN blocks AS b_synced ON s.synced_height = b_synced.block_height
LEFT JOIN blocks AS b_birthday ON s.birthday_height = b_birthday.block_height
ORDER BY w.id
`

type ListWalletsRow struct {
	ID                     int64
	WalletName             string
	IsImported             bool
	ManagerVersion         int64
	IsWatchOnly            bool
	SyncedHeight           sql.NullInt64
	BirthdayHeight         sql.NullInt64
	Birthday               sql.NullTime
	UpdatedAt              sql.NullTime
	SyncedBlockHash        []byte
	SyncedBlockTimestamp   sql.NullInt64
	BirthdayBlockHash      []byte
	BirthdayBlockTimestamp sql.NullInt64
}

func (q *Queries) ListWallets(ctx context.Context) ([]ListWalletsRow, error) {
	rows, err := q.query(ctx, q.listWalletsStmt, ListWallets)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWalletsRow
	for rows.Next() {
		var i ListWalletsRow
		if err := rows.Scan(
			&i.ID,
			&i.WalletName,
			&i.IsImported,
			&i.ManagerVersion,
			&i.IsWatchOnly,
			&i.SyncedHeight,
			&i.BirthdayHeight,
			&i.Birthday,
			&i.UpdatedAt,
			&i.SyncedBlockHash,
			&i.SyncedBlockTimestamp,
			&i.BirthdayBlockHash,
			&i.BirthdayBlockTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateWalletSecrets = `-- name: UpdateWalletSecrets :execrows
UPDATE wallet_secrets
SET
    master_priv_params = ?,
    encrypted_crypto_priv_key = ?,
    encrypted_crypto_script_key = ?,
    encrypted_master_hd_priv_key = ?
WHERE wallet_id = ?
`

type UpdateWalletSecretsParams struct {
	MasterPrivParams         []byte
	EncryptedCryptoPrivKey   []byte
	EncryptedCryptoScriptKey []byte
	EncryptedMasterHdPrivKey []byte
	WalletID                 int64
}

func (q *Queries) UpdateWalletSecrets(ctx context.Context, arg UpdateWalletSecretsParams) (int64, error) {
	result, err := q.exec(ctx, q.updateWalletSecretsStmt, UpdateWalletSecrets,
		arg.MasterPrivParams,
		arg.EncryptedCryptoPrivKey,
		arg.EncryptedCryptoScriptKey,
		arg.EncryptedMasterHdPrivKey,
		arg.WalletID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const UpdateWalletSyncState = `-- name: UpdateWalletSyncState :execrows
UPDATE wallet_sync_states
SET
    -- If synced_height param is NOT NULL, use it. Otherwise, keep existing value.
    synced_height = coalesce(?1, synced_height),

    -- If birthday_height param is NOT NULL, use it. Otherwise, keep existing value.
    birthday_height = coalesce(?2, birthday_height),

    -- If birthday param is NOT NULL, use it. Otherwise, keep existing value.
    birthday = coalesce(?3, birthday),

    -- Always update timestamp to current database time.
    updated_at = current_timestamp
WHERE
    wallet_id = ?4
`

type UpdateWalletSyncStateParams struct {
	SyncedHeight   sql.NullInt64
	BirthdayHeight sql.NullInt64
	Birthday       sql.NullTime
	WalletID       int64
}

func (q *Queries) UpdateWalletSyncState(ctx context.Context, arg UpdateWalletSyncStateParams) (int64, error) {
	result, err := q.exec(ctx, q.updateWalletSyncStateStmt, UpdateWalletSyncState,
		arg.SyncedHeight,
		arg.BirthdayHeight,
		arg.Birthday,
		arg.WalletID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
