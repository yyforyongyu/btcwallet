// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: key_scopes.sql

package sqlcsqlite

import (
	"context"
)

const AllocateAccountNumber = `-- name: AllocateAccountNumber :one
UPDATE key_scopes
SET last_account_number = last_account_number + 1
WHERE id = ?
RETURNING id, last_account_number
`

type AllocateAccountNumberRow struct {
	ID                int64
	LastAccountNumber int64
}

// Atomically allocates the next account number for a key scope.
// Returns the scope_id and the allocated account number.
// SQLite limitation: Can't combine UPDATE...RETURNING with INSERT in a single
// CTE (unlike Postgres). So, we call this first, then pass the returned number
// to CreateAccount, within the same SQL transaction.
func (q *Queries) AllocateAccountNumber(ctx context.Context, id int64) (AllocateAccountNumberRow, error) {
	row := q.queryRow(ctx, q.allocateAccountNumberStmt, AllocateAccountNumber, id)
	var i AllocateAccountNumberRow
	err := row.Scan(&i.ID, &i.LastAccountNumber)
	return i, err
}

const CreateKeyScope = `-- name: CreateKeyScope :one
INSERT INTO key_scopes (
    wallet_id,
    purpose,
    coin_type,
    encrypted_coin_pub_key,
    internal_type_id,
    external_type_id
) VALUES (
    ?, ?, ?, ?, ?, ?
)
ON CONFLICT (wallet_id, purpose, coin_type) DO NOTHING
RETURNING id
`

type CreateKeyScopeParams struct {
	WalletID            int64
	Purpose             int64
	CoinType            int64
	EncryptedCoinPubKey []byte
	InternalTypeID      int64
	ExternalTypeID      int64
}

// Creates a new key scope for a wallet and returns its ID.
func (q *Queries) CreateKeyScope(ctx context.Context, arg CreateKeyScopeParams) (int64, error) {
	row := q.queryRow(ctx, q.createKeyScopeStmt, CreateKeyScope,
		arg.WalletID,
		arg.Purpose,
		arg.CoinType,
		arg.EncryptedCoinPubKey,
		arg.InternalTypeID,
		arg.ExternalTypeID,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const DeleteKeyScope = `-- name: DeleteKeyScope :execrows
DELETE FROM key_scopes
WHERE id = ?
`

// Deletes a key scope by its ID.
func (q *Queries) DeleteKeyScope(ctx context.Context, id int64) (int64, error) {
	result, err := q.exec(ctx, q.deleteKeyScopeStmt, DeleteKeyScope, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const DeleteKeyScopeSecrets = `-- name: DeleteKeyScopeSecrets :execrows
DELETE FROM key_scope_secrets
WHERE scope_id = ?
`

// Deletes the secrets for a key scope.
func (q *Queries) DeleteKeyScopeSecrets(ctx context.Context, scopeID int64) (int64, error) {
	result, err := q.exec(ctx, q.deleteKeyScopeSecretsStmt, DeleteKeyScopeSecrets, scopeID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const GetKeyScopeByID = `-- name: GetKeyScopeByID :one
SELECT
    id,
    wallet_id,
    purpose,
    coin_type,
    encrypted_coin_pub_key,
    internal_type_id,
    external_type_id
FROM key_scopes
WHERE id = ?
`

type GetKeyScopeByIDRow struct {
	ID                  int64
	WalletID            int64
	Purpose             int64
	CoinType            int64
	EncryptedCoinPubKey []byte
	InternalTypeID      int64
	ExternalTypeID      int64
}

// Retrieves a key scope by its ID.
func (q *Queries) GetKeyScopeByID(ctx context.Context, id int64) (GetKeyScopeByIDRow, error) {
	row := q.queryRow(ctx, q.getKeyScopeByIDStmt, GetKeyScopeByID, id)
	var i GetKeyScopeByIDRow
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.Purpose,
		&i.CoinType,
		&i.EncryptedCoinPubKey,
		&i.InternalTypeID,
		&i.ExternalTypeID,
	)
	return i, err
}

const GetKeyScopeByWalletAndScope = `-- name: GetKeyScopeByWalletAndScope :one
SELECT
    id,
    wallet_id,
    purpose,
    coin_type,
    encrypted_coin_pub_key,
    internal_type_id,
    external_type_id
FROM key_scopes
WHERE wallet_id = ? AND purpose = ? AND coin_type = ?
`

type GetKeyScopeByWalletAndScopeParams struct {
	WalletID int64
	Purpose  int64
	CoinType int64
}

type GetKeyScopeByWalletAndScopeRow struct {
	ID                  int64
	WalletID            int64
	Purpose             int64
	CoinType            int64
	EncryptedCoinPubKey []byte
	InternalTypeID      int64
	ExternalTypeID      int64
}

// Retrieves a key scope by wallet ID, purpose, and coin type.
func (q *Queries) GetKeyScopeByWalletAndScope(ctx context.Context, arg GetKeyScopeByWalletAndScopeParams) (GetKeyScopeByWalletAndScopeRow, error) {
	row := q.queryRow(ctx, q.getKeyScopeByWalletAndScopeStmt, GetKeyScopeByWalletAndScope, arg.WalletID, arg.Purpose, arg.CoinType)
	var i GetKeyScopeByWalletAndScopeRow
	err := row.Scan(
		&i.ID,
		&i.WalletID,
		&i.Purpose,
		&i.CoinType,
		&i.EncryptedCoinPubKey,
		&i.InternalTypeID,
		&i.ExternalTypeID,
	)
	return i, err
}

const GetKeyScopeSecrets = `-- name: GetKeyScopeSecrets :one
SELECT
    scope_id,
    encrypted_coin_priv_key
FROM key_scope_secrets
WHERE scope_id = ?
`

// Retrieves the secrets for a key scope.
func (q *Queries) GetKeyScopeSecrets(ctx context.Context, scopeID int64) (KeyScopeSecret, error) {
	row := q.queryRow(ctx, q.getKeyScopeSecretsStmt, GetKeyScopeSecrets, scopeID)
	var i KeyScopeSecret
	err := row.Scan(&i.ScopeID, &i.EncryptedCoinPrivKey)
	return i, err
}

const InsertKeyScopeSecrets = `-- name: InsertKeyScopeSecrets :exec
INSERT INTO key_scope_secrets (
    scope_id,
    encrypted_coin_priv_key
) VALUES (
    ?, ?
)
`

type InsertKeyScopeSecretsParams struct {
	ScopeID              int64
	EncryptedCoinPrivKey []byte
}

// Inserts secrets for a key scope. encrypted_coin_priv_key may be NULL for
// watch-only scopes.
func (q *Queries) InsertKeyScopeSecrets(ctx context.Context, arg InsertKeyScopeSecretsParams) error {
	_, err := q.exec(ctx, q.insertKeyScopeSecretsStmt, InsertKeyScopeSecrets, arg.ScopeID, arg.EncryptedCoinPrivKey)
	return err
}

const ListKeyScopesByWallet = `-- name: ListKeyScopesByWallet :many
SELECT
    id,
    wallet_id,
    purpose,
    coin_type,
    encrypted_coin_pub_key,
    internal_type_id,
    external_type_id
FROM key_scopes
WHERE wallet_id = ?
ORDER BY id
`

type ListKeyScopesByWalletRow struct {
	ID                  int64
	WalletID            int64
	Purpose             int64
	CoinType            int64
	EncryptedCoinPubKey []byte
	InternalTypeID      int64
	ExternalTypeID      int64
}

// Lists all key scopes for a wallet, ordered by ID.
func (q *Queries) ListKeyScopesByWallet(ctx context.Context, walletID int64) ([]ListKeyScopesByWalletRow, error) {
	rows, err := q.query(ctx, q.listKeyScopesByWalletStmt, ListKeyScopesByWallet, walletID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListKeyScopesByWalletRow
	for rows.Next() {
		var i ListKeyScopesByWalletRow
		if err := rows.Scan(
			&i.ID,
			&i.WalletID,
			&i.Purpose,
			&i.CoinType,
			&i.EncryptedCoinPubKey,
			&i.InternalTypeID,
			&i.ExternalTypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SetLastAccountNumber = `-- name: SetLastAccountNumber :exec
UPDATE key_scopes
SET last_account_number = ?
WHERE id = ?
`

type SetLastAccountNumberParams struct {
	LastAccountNumber int64
	ID                int64
}

// Sets the last_account_number for a key scope. This is intended for testing
// the account number overflow behavior without creating billions of accounts.
func (q *Queries) SetLastAccountNumber(ctx context.Context, arg SetLastAccountNumberParams) error {
	_, err := q.exec(ctx, q.setLastAccountNumberStmt, SetLastAccountNumber, arg.LastAccountNumber, arg.ID)
	return err
}
